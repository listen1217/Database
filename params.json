{"body":"Database System ReadMe file:\r\n================\r\nby Xin Li\r\n\r\nTo compile the code in GNU/Linux or Mac, use command \"make\", the makefile is contained in the codes.\r\n\r\nThe database contents in my local use TPC-H benchmark 10Mb version, the code can also run on 1Gb data.\r\nTo use the data of TPC-H 10Mb benchmark, please refer to:\r\nhttp://www.tpc.org/tpch/\r\n\r\nSince the size is large, the contents of my database is not included in the codes.\r\n\r\nIn main.h, the following 3 strings need to be changed according to environment settings.\r\n\r\nchar *dbfile_dir // dir where binary heap files should be stored\r\nchar *tpch_dir;//TPC-H benchmark's location\r\nchar *catalog_path;// the catalog of database, the catalog file is included for the TPC-h benchmark, this can be set to default\r\n\r\n\r\nthe database use some file to store the internal stuffs, In Defs.h,  \"dbfile.meta\" is the name for these files\r\n\r\n\r\nSeveral test case can be as following:\r\n======================================\r\n(q1)\r\n============================================================\r\nSELECT SUM (ps.ps_supplycost)\r\nFROM part AS p, supplier AS s, partsupp AS ps\r\nWHERE (p.p_partkey = ps.ps_partkey) AND\r\n    (s.s_suppkey = ps.ps_suppkey) AND\r\n\t  (s.s_acctbal > 2500)\r\n\r\n\r\n(q2)\r\n============================================================\r\nSELECT SUM (c.c_acctbal)\r\nFROM customer AS c, orders AS o\r\nWHERE (c.c_custkey = o.o_custkey) AND\r\n\t  (o.o_totalprice < 10000)\r\n\r\n\r\nANSWER: 1.33123e+08 (17.31 sec) \r\n\r\n\r\n\r\n(q3)\r\n============================================================\r\ncaution!!!!!!!!tooooooo slow!!!!!!!! in 1Gb data\r\n\r\nSELECT l.l_orderkey, l.l_partkey, l.l_suppkey\r\nFROM lineitem AS l\r\nWHERE (l.l_returnflag = 'R') AND\r\n\t(l.l_discount < 0.04 OR l.l_shipmode = 'MAIL') AND \r\n\t(l.l_orderkey > 5000) AND (l.l_orderkey < 6000)\r\n\r\n\r\nANSWER: 109 rows in set (17.47 sec)\r\n\r\n(q4)\r\n=====\r\nSELECT ps.ps_partkey, ps.ps_suppkey, ps.ps_availqty \r\nFROM partsupp AS ps \r\nWHERE (ps.ps_partkey < 100) AND (ps.ps_suppkey < 50)\r\n\r\nANSWER: 48 rows (1.95 sec)\r\n\r\n(q5)\r\n============================================================\r\n\r\nSELECT SUM (l.l_discount)\r\nFROM customer AS c, orders AS o, lineitem AS l\r\nWHERE (c.c_custkey = o.o_custkey) AND\r\n\t  (o.o_orderkey = l.l_orderkey) AND\r\n\t  (c.c_name = 'Customer#000070919') AND\r\n\t  (l.l_quantity > 30) AND (l.l_discount < 0.03)\r\n\r\nANSWER: 0.0075 (55.4 sec)\r\n\r\n\r\n(q6)\r\n===========================================================\r\nSELECT DISTINCT s.s_name\r\nFROM supplier AS s, part AS p, partsupp AS ps\r\nWHERE (s.s_suppkey = ps.ps_suppkey) AND\r\n\t  (p.p_partkey = ps.ps_partkey) AND\r\n\t  (p.p_mfgr = 'Manufacturer#4') AND\r\n\t  (ps.ps_supplycost < 350)\r\n\r\n\r\nANSWER: 9964 rows (1.51 sec)\r\n\r\n\r\n(q7)\r\n===========================================================\r\nSELECT SUM (l.l_extendedprice * (1 - l.l_discount)), l.l_orderkey, o.o_orderdate, o.o_shippriority\r\nFROM customer AS c, orders AS o, lineitem AS l \r\nWHERE (c.c_mktsegment = 'BUILDING') AND \r\n      (c.c_custkey = o.o_custkey) AND (l.l_orderkey = o.o_orderkey) AND\r\n\t  (l.l_orderkey < 100 OR o.o_orderkey < 100)\r\nGROUP BY l.l_orderkey, o.o_orderdate, o.o_shippriority\r\n\r\nANSWER: 7 rows (41.2 sec)\r\n\r\n===========================================================\r\n\r\n\r\n\r\nThe instructions of the database\r\n=================================\r\nCREATE TABLE\r\n============\r\nThis one is pretty self-explanatory. If someone gives you this command, you create the associated table and remember its schema. Here is an example of the command:\r\nCREATE TABLE mytable (att1 INTEGER, att2 DOUBLE, att3 STRING) AS HEAP;\r\n\r\nThe “AS” part of the command will include either “SORTED” or “HEAP”.\r\nIf the type is SORTED, then there is also a required “ON” clause that tells the system what attributes to sort on:\r\nCREATE TABLE MYTABLE (att1 INTEGER, att2 DOUBLE, att3 STRING) AS SORTED ON att1, att2;\r\n\r\ndon’t actually support use of the sorted file type.\r\n\r\nINSERT INTO\r\n============\r\nIn this one, you simply bulk load (append) to the specified database table from the specified text file. The name of the text file will be given in single quotes:\r\nINSERT ‘myfile’ INTO mytable;\r\nDROP TABLE\r\n============\r\nThis removes the relation from the system and kills the corresponding binary file:\r\nDROP TABLE mytable;\r\nSET OUTPUT\r\n============\r\nBasically, this tells you where the result of the output table operation at the top of the query plan goes. It is legal for a user to give the sting STDOUT as the output location, in which case you write the output to the screen. The command is as follows:\r\nSET OUTPUT STDOUT;\r\nWhich writes the result to the screen. Or:\r\nSET OUTPUT ‘myfile’;\r\nFinally, there is a third option:\r\nSET OUTPUT NONE;\r\nThis option makes it so that you do not actually execute any query that you are given; you simply write out the query plan to the screen\r\nSELECT...\r\n============\r\nFinally, run SQL\r\n","google":"","name":"Database","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":""}